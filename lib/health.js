// Generated by CoffeeScript 1.6.3
(function() {
  var async, bind, cbTimeout, createContainer, docker, dockerVersion, dockworkerGetServiceToken, dockworkerTestTerminal, find, getDockworker, getReliableRepo, imageCache, lengthOf, localhost, request, startContainer, stepError, stopContainer, testDockworker, timeIt, toEnv, toHttpClient, uuid;

  async = require('async');

  uuid = require('uuid');

  request = require('request');

  docker = require('./dockerProxy')();

  imageCache = require('./imageCache');

  cbTimeout = require('callback-timeout');

  localhost = 'http://localhost';

  find = require('array-find');

  lengthOf = function(length) {
    return function(arr) {
      return arr.length === length;
    };
  };

  bind = function(fn) {
    var bindArgs, newFn;
    bindArgs = Array.prototype.slice.call(arguments, 1);
    newFn = function() {
      var args;
      args = Array.prototype.slice.call(arguments);
      args = bindArgs.concat(args);
      return fn.apply(null, args);
    };
    newFn.name = fn.name;
    newFn._name = fn._name;
    return newFn;
  };

  toEnv = function(obj) {
    return Object.keys(obj).reduce(function(env, key) {
      env.push(key + '=' + obj[key]);
      return env;
    }, []);
  };

  toHttpClient = function(host, port) {
    var client, makeAcceptPath;
    if (port) {
      host = host + ':' + port;
    }
    makeAcceptPath = function(fn) {
      return function(path, opts, cb) {
        var url;
        url = host + path;
        return fn(url, opts, cb);
      };
    };
    client = makeAcceptPath(request);
    client.host = host;
    ['get', 'post', 'patch', 'put', 'del'].forEach(function(method) {
      return client[method] = makeAcceptPath(request[method].bind(request));
    });
    return client;
  };

  timeIt = function(session, fn) {
    return function() {
      var args, cb, newCb, start;
      start = Date.now();
      args = Array.prototype.slice.call(arguments);
      cb = args.pop();
      newCb = function() {
        var timings;
        timings = session.timings;
        timings = timings || {};
        timings[fn._name || fn.name || uuid()] = Date.now() - start;
        session.timings = timings;
        console.log(timings);
        return cb.apply(null, arguments);
      };
      args.push(newCb);
      return fn.apply(null, args);
    };
  };

  stepError = function(code, messageOrErr, step) {
    var err;
    if (typeof code !== 'number') {
      step = messageOrErr;
      messageOrErr = code;
      code = null;
    }
    if (typeof messageOrErr === 'string') {
      err = new Error(messageOrErr);
      step = messageOrErr;
    } else {
      err = messageOrErr;
      code = 500;
    }
    err.step = step;
    err.code = code;
    return err;
  };

  dockerVersion = function(cb) {
    console.log("dockerVersion");
    return docker.version(function(err, versionInfo) {
      if (err) {
        console.log("dockerVersion err: ", err);
        err = stepError(err, 'Checking docker version');
      }
      return cb(err);
    });
  };

  dockerVersion._name = 'dockerVersion';

  getReliableRepo = function() {
    var helloWorldNode;
    helloWorldNode = 'registry.runnable.com/runnable/5320c7e2be28fdcc6917cb82';
    if (imageCache[helloWorldNode]) {
      return helloWorldNode;
    } else {
      return find(Object.keys(imageCache), lengthOf(helloWorldNode.length));
    }
  };

  createContainer = function(session, cb) {
    var body, self, servicesToken;
    self = this;
    servicesToken = 'services-' + uuid.v4();
    body = {
      Image: getReliableRepo(),
      Tty: true,
      Volumes: {
        '/dockworker': {}
      },
      PortSpecs: ['80', '15000'],
      Cmd: ['/dockworker/bin/node', '/dockworker'],
      Env: toEnv({
        SERVICES_TOKEN: servicesToken,
        RUNNABLE_START_CMD: 'npm start'
      })
    };
    return docker.createContainer(body, function(err, container) {
      if (err) {
        err.step = 'createContainer';
        return cb(err);
      } else {
        session.container = container;
        session.servicesToken = servicesToken;
        return cb();
      }
    });
  };

  createContainer._name = 'createContainer';

  startContainer = function(session, cb) {
    var container;
    container = session.container;
    return container.start({
      Binds: ["/home/ubuntu/dockworker:/dockworker:ro"],
      PortBindings: {
        "80/tcp": [{}],
        "15000/tcp": [{}]
      }
    }, function(err) {
      if (err) {
        err = stepError(err, 'Starting container');
      }
      return cb(err);
    });
  };

  startContainer._name = 'startContainer';

  getDockworker = function(session, cb) {
    var container;
    container = session.container;
    return container.inspect(function(err, data) {
      var dockworker, port;
      if (err) {
        return cb(stepError(err, 'Inspecting container'));
      } else if (!data || !data.NetworkSettings || !data.NetworkSettings.Ports || !data.NetworkSettings.Ports['15000/tcp'] || !data.NetworkSettings.Ports['15000/tcp'][0] || !data.NetworkSettings.Ports['15000/tcp'][0].HostPort) {
        return cb(stepError('Inspecting container (missing ports)'));
      } else {
        port = data.NetworkSettings.Ports['15000/tcp'][0].HostPort;
        dockworker = toHttpClient(localhost, port);
        session.dockworker = dockworker;
        return cb();
      }
    });
  };

  getDockworker._name = 'inspectContainer';

  dockworkerGetServiceToken = function(session, cb) {
    var dockworker, servicesToken;
    dockworker = session.dockworker;
    servicesToken = session.servicesToken;
    return dockworker.get('/api/servicesToken', function(err, res, body) {
      if (err) {
        if (~err.message.indexOf('ECONNRESET') || ~err.message.indexOf('hang up')) {
          setTimeout(function() {
            return dockworkerGetServiceToken(session, cb);
          }, 200);
          return;
        }
        return cb(stepError(err, 'Getting dockworker servicesToken'));
      } else if (res.statusCode !== 200) {
        return cb(stepError(400, 'Failed to get dockworker servicesToken (statusCode:' + res.statusCode + ')'));
      } else if (body !== servicesToken) {
        return cb(stepError(400, 'Dockworker servicesToken mismatch'));
      } else {
        return cb();
      }
    });
  };

  dockworkerGetServiceToken._name = 'dockworkerGetServiceToken';

  dockworkerTestTerminal = function(session, cb) {
    var dockworker, noErrExpectSuccess;
    dockworker = session.dockworker;
    noErrExpectSuccess = function(cb) {
      return function(err, res, body) {
        if (err) {
          return cb(err);
        } else {
          if (res.statusCode !== 200 && res.statusCode !== 204) {
            err = new Error('dockworker unexpected status code ' + res.statusCode);
            err.stack = body;
            return cb(err);
          } else {
            return cb();
          }
        }
      };
    };
    return async.parallel([
      function(cb) {
        return dockworker.get('/api/checkTermUp', noErrExpectSuccess(cb));
      }, function(cb) {
        return dockworker.get('/api/checkLogUp', noErrExpectSuccess(cb));
      }
    ], cb);
  };

  dockworkerTestTerminal._name = 'dockworkerTestTerminal';

  testDockworker = function(session, cb) {
    return async.series([timeIt(session, bind(dockworkerGetServiceToken, session)), timeIt(session, bind(dockworkerTestTerminal, session))], cb);
  };

  testDockworker._name = 'testDockworker';

  stopContainer = function(session, cb) {
    var container;
    container = session.container;
    return container.stop(function(err) {
      if (err) {
        return cb(stepError(err, 'Stopping container'));
      } else {
        return cb();
      }
    });
  };

  stopContainer._name = 'stopContainer';

  module.exports = function(req, res, next) {
    var session;
    session = {};
    return async.series([timeIt(session, dockerVersion), timeIt(session, bind(createContainer, session)), timeIt(session, bind(startContainer, session)), timeIt(session, bind(getDockworker, session)), timeIt(session, bind(testDockworker, session)), timeIt(session, bind(stopContainer, session))], function(err) {
      var timings;
      timings = session.timings;
      if (err) {
        return res.json(err.code || 500, {
          message: err.message,
          step: err.step,
          timings: timings,
          stack: err.stack
        });
      } else {
        return res.json(200, {
          status: 'healthy',
          timings: timings
        });
      }
    });
  };

}).call(this);

/*
//@ sourceMappingURL=health.map
*/
