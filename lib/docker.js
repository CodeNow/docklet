// Generated by CoffeeScript 1.6.3
(function() {
  var cacheImages, checkCache, checkImage, checkUp, configs, findImage, images, ip, pullImage, queue, redis, request;

  configs = require('./configs');

  request = require('request');

  queue = require('./queue');

  redis = require('./client');

  ip = require('./ip');

  images = require('./imageCache');

  cacheImages = function(cb) {
    return request({
      method: 'GET',
      url: "http://" + configs.docker_host + ":" + configs.bouncer_port + "/images/json",
      json: true,
      headers: {
        token: configs.authToken
      }
    }, function(err, res) {
      if (err) {
        return cb(err);
      } else {
        if (res.statusCode !== 200) {
          return cb(new Error("docker error " + res.body));
        } else {
          res.body.forEach(function(image) {
            var tag;
            tag = image.RepoTags[0].replace(':latest', '');
            return images[tag] = true;
          });
          return cb();
        }
      }
    });
  };

  pullImage = function(repo, cb) {
    return queue.push(repo, function(err) {
      if (err == null) {
        images[repo] = true;
      }
      return cb(err);
    });
  };

  checkCache = function(repo) {
    return repo in images;
  };

  checkImage = function(repo, cb) {
    return request({
      method: 'GET',
      url: "http://" + configs.docker_host + ":" + configs.bouncer_port + "/images/" + repo + "/json",
      json: true,
      headers: {
        token: configs.authToken
      }
    }, function(err, res) {
      if (err) {
        return cb(err);
      } else {
        if (res.statusCode !== 200) {
          return cb(new Error("docker error " + res.body));
        } else {
          images[repo] = true;
          return cb(null);
        }
      }
    });
  };

  findImage = function(data, cb) {
    if (checkCache(data.repo)) {
      return process.nextTick(function() {
        return cb(null, ip);
      });
    } else {
      return checkImage(data.repo, function(err) {
        var pubsub;
        if (err) {
          if (data.job) {
            data.job = false;
            pubsub = require('redis').createClient(configs.redisPort, configs.redisHost);
            pubsub.subscribe("" + data.servicesToken + ":dockletReady");
            pubsub.on('message', function(key, ip) {
              cb(null, ip);
              return pubsub.quit(null);
            });
            pubsub.on('ready', function() {
              return redis.publish('dockletRequest', JSON.stringify(data));
            });
            return setTimeout(function() {
              pubsub.quit(null);
              err = new Error('timed out searching for image');
              err.code = 404;
              return cb(err);
            }, 1000 * 5);
          } else {
            return pullImage(data.repo, cb);
          }
        } else {
          return cb(null, ip);
        }
      });
    }
  };

  checkUp = function() {
    var up;
    up = false;
    request({
      method: 'GET',
      url: "http://" + configs.docker_host + ":" + configs.bouncer_port + "/version",
      json: true,
      headers: {
        token: configs.authToken
      }
    }, function(err, res) {
      if (err || res.statusCode !== 200) {
        return (require('./register')).deregister();
      } else {
        return up = true;
      }
    });
    return setTimeout(function() {
      if (!up) {
        return (require('./register')).deregister();
      }
    }, 1000 * 3);
  };

  module.exports = {
    checkCache: checkCache,
    findImage: findImage,
    cacheImages: cacheImages,
    pullImage: pullImage,
    checkUp: checkUp
  };

  setInterval(cacheImages, 1000 * 60 * 4 + 1000 * 60 * 2 * Math.random(), function() {});

}).call(this);

/*
//@ sourceMappingURL=docker.map
*/
