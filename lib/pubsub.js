// Generated by CoffeeScript 1.6.3
(function() {
  var async, client, configs, docker, dockerClient, ip, pruneContainer, pruneContainers, pubsub, raceToFind;

  configs = require('./configs');

  async = require('async');

  pubsub = require('redis').createClient(configs.redisPort, configs.redisHost);

  dockerClient = require('docker.js')({
    host: "http://" + configs.docker_host + ":" + configs.bouncer_port,
    token: configs.authToken
  });

  docker = require('./docker');

  client = require('./client');

  ip = require('./ip');

  pubsub.on('message', function(key, json) {
    var data, err, whitelist;
    try {
      data = JSON.parse(json);
      if (key === 'dockletRequest') {
        return raceToFind(data);
      } else if (key === 'dockletPrune') {
        whitelist = data;
        return dockerClient.listContainers({
          queryParams: {
            all: true
          }
        }, function(err, containers) {
          var containersToPrune, whitelistHash;
          if (err) {
            return console.error(err);
          } else {
            whitelistHash = {};
            whitelist.forEach(function(containerId) {
              return whitelistHash[containerId] = true;
            });
            containersToPrune = containers.filter(function(container) {
              var containerId;
              containerId = container.Id.substring(0, 12);
              return !whitelistHash[containerId];
            });
            return pruneContainers(containersToPrune);
          }
        });
      } else {
        throw new Error("Docklet received unknown message: " + key);
      }
    } catch (_error) {
      err = _error;
      return console.error(err);
    }
  });

  pubsub.subscribe('dockletPrune');

  pubsub.subscribe('dockletRequest');

  pruneContainers = function(containers) {
    return async.forEachSeries(containers, pruneContainer, function(err) {
      if (err) {
        return console.error(err);
      }
    });
  };

  pruneContainer = function(container, cb) {
    var containerId;
    containerId = container.Id.substring(0, 12);
    return dockerClient.inspectContainer(containerId, function(err, res) {
      if (err) {
        return cb(err);
      } else {
        if (!res.State || res.State.Running) {
          return cb();
        } else {
          return dockerClient.removeContainer(containerId, cb);
        }
      }
    });
  };

  raceToFind = function(data) {
    return docker.findImage(data, function(err) {
      if (err) {
        return console.error(err);
      } else {
        return client.setnx("" + data.servicesToken + ":dockletLock", true, function(err, lock) {
          if (err) {
            throw err;
          }
          if (lock) {
            return client.publish("" + data.servicesToken + ":dockletReady", ip);
          }
        });
      }
    });
  };

}).call(this);

/*
//@ sourceMappingURL=pubsub.map
*/
